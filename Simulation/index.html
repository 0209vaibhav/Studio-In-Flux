<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Studio Circulation Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        font-family: Arial, sans-serif;
        overflow: hidden;
        height: 100vh;
      }
      #left-panel {
        width: 300px;
        padding: 20px;
        background-color: #ffffff;
        height: 100vh;
        overflow-y: auto;
        box-sizing: border-box;
        border-right: 1px solid #000000;
        position: fixed;
        left: 0;
        top: 0;
        z-index: 1;
      }
      #right-panel {
        width: 300px;
        padding: 20px;
        background-color: #ffffff;
        height: 100vh;
        overflow-y: auto;
        box-sizing: border-box;
        border-left: 1px solid #000000;
        position: fixed;
        right: 0;
        top: 0;
        z-index: 1;
      }
      #simulation-container {
        position: fixed;
        left: 300px;
        right: 300px;
        top: 0;
        height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background-color: #ffffff;
        overflow: hidden;
      }
      .simulation-heading {
        position: absolute;
        top: 20px;
        text-align: center;
        z-index: 1;
      }
      .simulation-heading h1 {
        margin: 0 0 0 0;
        font-size: 48px;
        font-weight: bold;
        color: #000000;
      }
      .simulation-heading .subtitle {
        margin: 5px 0;
        font-size: 14px;
        color: #333333;
      }
      .simulation-heading .credits {
        font-size: 12px;
        color: #666666;
        font-style: italic;
      }
      canvas {
        display: block;
        margin: auto;
      }
      .control-group {
        margin-bottom: 10px;
        border-bottom: 1px solid #000000;
        padding-bottom: 10px;
      }
      .panel-heading {
        padding: 15px 0;
        margin-bottom: 20px;
        border-bottom: 2px solid #000000;
        text-align: center;
      }
      .panel-heading h2 {
        margin: 0;
        font-size: 18px;
        font-weight: bold;
        color: #000000;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }
      .control-group h3 {
        margin-top: 0;
        margin-bottom: 5px;
        color: #000000;
        font-size: 14px;
        font-weight: bold;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .control-group h3::before,
      .control-group h4::before {
        font-family: Arial, sans-serif;
        font-size: 14px;
      }
      button, select, input {
        margin: 5px 0;
        padding: 8px;
        width: 100%;
        box-sizing: border-box;
        border: 1px solid #000000;
        border-radius: 4px;
        background-color: #ffffff;
        color: #000000;
      }
      button:hover, select:hover {
        background-color: #f0f0f0;
      }
      button:active, select:active {
        background-color: #e0e0e0;
      }
      .slider-container {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .slider-container input[type="range"] {
        flex: 1;
        accent-color: #000000;
      }
      .slider-container span {
        min-width: 10px;
        text-align: right;
        color: #000000;
      }
      #legend-canvas {
        width: 100%;
        height: 80px; /* Increased height to accommodate text */
        display: block;
        margin: 0;
        padding: 0;
      }
      .control-group {
        overflow: visible;
      }
      /* Add styles for statistics panel */
      #stats-container {
        border-radius: 4px;
      }
      .stat-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
        font-size: 12px;
      }
      .stat-label {
        flex-grow: 1;
        color: #000000;
      }
      .stat-value {
        text-align: right;
        white-space: nowrap;
      }
      .unit {
        margin-left: 5px;
        color: #666;
        font-size: 12px;
      }
      /* Add styles for operator legend */
      .operator-legend {
        margin-top: 10px;
        padding: 5px;
        border-radius: 4px;
      }
      .operator-legend-item {
        display: flex;
        align-items: center;
        margin: 5px 0;
        font-size: 12px;
      }
      .operator-legend-color {
        width: 15px;
        height: 15px;
        border-radius: 50%;
        margin-right: 10px;
      }
      .operator-legend-text {
        color: #333;
      }
      .stat-group {
        margin-bottom: 15px;
      }
      .stat-group h4 {
        margin: 5px 0;
        font-size: 12px;
        color: #000000;
        display: flex;
        align-items: center;
        gap: 8px;
      }
    </style>
  </head>
  <body>
    <div id="left-panel">
        <div class="panel-heading">
          <h2>üéÆ Simulation Controls</h2>
        </div>
        <div class="control-group">
            <h3>üìä Number of Divisions</h3>
            <div class="slider-container">
              <span>Divisions:</span>
              <input type="range" id="divisions-slider" min="1" max="3" value="2" step="1">
              <span id="divisions-value">4</span>
            </div>
          </div>
      <div class="control-group">
        <h3>üîÑ Corridor Loading Type</h3>
        <select id="corridor-type-selector">
          <option value="single">Single Loaded</option>
          <option value="double">Double Loaded</option>
        </select>
      </div>
      <div class="control-group">
        <h3>‚¨ÜÔ∏è Entry Point</h3>
        <select id="entry-selector">
          <option value="default">Default</option>
          <option value="set">Set Entry</option>
        </select>
      </div>
      <div class="control-group">
        <h3>‚¨áÔ∏è Exit Point</h3>
        <select id="exit-selector">
          <option value="default">Default</option>
          <option value="set">Set Exit</option>
        </select>
      </div>
      <div class="control-group">
        <h3>ü™ë Number of Desks</h3>
        <div class="slider-container">
          <span>Desks:</span>
          <input type="range" id="desks-slider" min="0" max="100" value="10" step="1">
          <span id="desks-value">10</span>
        </div>
      </div>
      <div class="control-group">
        <h3>üìê Desk Arrangement Pattern</h3>
        <select id="arrangement-selector">
          <option value="row">Row Arrangement</option>
          <option value="column">Column Arrangement</option>
          <option value="cluster">Cluster Arrangement</option>
        </select>
      </div>
      <div class="control-group">
        <h3>üë• Number of Operators</h3>
        <div class="slider-container">
          <span>Count:</span>
          <input type="range" id="operators-slider" min="0" max="100" value="5" step="1">
          <span id="operators-value">5</span>
        </div>
      </div>
      <div class="control-group">
        <h3>‚ö° Speed of Operators</h3>
        <div class="slider-container">
          <span>Speed:</span>
          <input type="range" id="speed-slider" min="1" max="10" value="1" step="1">
          <span id="speed-value">1</span>
        </div>
      </div>
      <div class="control-group">
        <h3>‚öôÔ∏è Simulation Controls</h3>
        <button id="start-stop-button">Start</button>
        <button id="reset-button">Reset Simulation</button>
      </div>
    </div>
    <div id="simulation-container">
      <div class="simulation-heading">
        <h1>STUDIO-IN-FLUX</h1>
        <div class="subtitle">Spatial AI by William Martin</div>
        <div class="subtitle">GSAPP 2024-2025, Columbia University</div>
        <div class="credits">by Manas Bhatia and Vaibhav Jain</div>
      </div>
    </div>
    <div id="right-panel">
      <div class="panel-heading">
        <h2>üìä Simulation Data</h2>
      </div>
      <div class="control-group">
        <h3>üå°Ô∏è Heat Map</h3>
        <canvas id="legend-canvas"></canvas>
        <button id="clear-heatmap-button">Clear Heat Map</button>
      </div>
      <div class="control-group">
        <h3>üé® Operator Colors</h3>
        <div class="operator-legend">
          <div class="operator-legend-item">
            <div class="operator-legend-color" style="background-color: rgb(0, 255, 0);"></div>
            <span class="operator-legend-text">Moving to Desk (Safe Distance >4ft)</span>
          </div>
          <div class="operator-legend-item">
            <div class="operator-legend-color" style="background-color: rgb(255, 255, 0);"></div>
            <span class="operator-legend-text">Moving to Desk (Warning Distance 2-3ft)</span>
          </div>
          <div class="operator-legend-item">
            <div class="operator-legend-color" style="background-color: rgb(255, 0, 0);"></div>
            <span class="operator-legend-text">Moving to Desk (Unsafe Distance <1ft)</span>
          </div>
          <div class="operator-legend-item">
            <div class="operator-legend-color" style="background-color: rgb(200, 200, 200); border: 3px solid black;"></div>
            <span class="operator-legend-text">Interacting with Owned Desk</span>
          </div>
          <div class="operator-legend-item">
            <div class="operator-legend-color" style="background-color: rgb(200, 200, 200); border: 3px solid black; position: relative;">
              <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 8px; height: 8px; border-right: 2px solid black; border-bottom: 2px solid black; transform: translate(-50%, -50%) rotate(45deg);"></div>
            </div>
            <span class="operator-legend-text">Task Completed</span>
          </div>
        </div>
      </div>
      <div class="control-group">
        <h3>üìà Simulation Statistics</h3>
        <div id="stats-container">
          <div class="stat-item">
            <span class="stat-label">Number of Desks:</span>
            <span id="total-desks-count">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Number of Operators:</span>
            <span id="total-operators-count">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Desks Interacted:</span>
            <span id="desks-interacted-count">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Operators Completed:</span>
            <span id="operators-completed-count">0</span>
          </div>
        </div>
      </div>
      <div class="control-group">
        <h3>üìè Area Statistics</h3>
        <div id="area-stats-container">
          <div class="stat-group">
            <h4>üè¢ STUDIO</h4>
            <div class="stat-item">
              <span class="stat-label">Total Studio Area:</span>
              <span class="stat-value">
                <span id="total-studio-area">0</span>
                <span class="unit">sq ft</span>
              </span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Main Corridor Area:</span>
              <span class="stat-value">
                <span id="main-corridor-area">0</span>
                <span class="unit">sq ft</span>
              </span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Total Desk Area:</span>
              <span class="stat-value">
                <span id="total-desk-area">0</span>
                <span class="unit">sq ft</span>
              </span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Total Non-Desk Area:</span>
              <span class="stat-value">
                <span id="total-non-desk-area">0</span>
                <span class="unit">sq ft</span>
              </span>
            </div>
          </div>
          <div class="stat-group">
            <h4>üèóÔ∏è DIVISIONS (Per Division)</h4>
            <div class="stat-item">
              <span class="stat-label">Total Area:</span>
              <span class="stat-value">
                <span id="division-total-area">0</span>
                <span class="unit">sq ft</span>
              </span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Desk Area:</span>
              <span class="stat-value">
                <span id="division-desk-area">0</span>
                <span class="unit">sq ft</span>
              </span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Non-Desk Area:</span>
              <span class="stat-value">
                <span id="division-non-desk-area">0</span>
                <span class="unit">sq ft</span>
              </span>
            </div>
          </div>
        </div>
      </div>
    </div>
    <script>
      // Add global variables
      let divisionsSlider, desksSlider, arrangementSelector, operatorsSlider;
      let divisions = 2;
      let desks = 10;
      let arrangement = "row";
      let operatorSpeed = 1;

      // Simple throttle function for smooth updates
      function throttle(func, limit) {
        let inThrottle;
        return function(...args) {
          if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
          }
        }
      }

      let cellSize = 10; // Initialize cellSize as a variable
      const studioSize = 54;
      const gridWidth = studioSize;
      const gridHeight = studioSize;
      const deskWidth = 2; // 2 ft
      const deskHeight = 6; // 2 ft
      const deskMargin = 1; // 1 ft buffer from boundaries for desk placement
      let uniformMargin = 80; // Canvas margin for white space

      let grid = [];
      let deskPositions = [];
      let operatorAgents = [];
      let operatorSource = { x: Math.floor(gridWidth / 2), y: -1 };
      let operatorExit = { x: Math.floor(gridWidth / 2), y: gridHeight };
      let placementMode = 'default';

      // Add distance map for pathfinding
      let distanceMap = [];
      
      // Add global variables for persistent path tracking
      let globalHeatMap = {};
      let maxVisits = 0;

      // Add simulation control variables
      let isSimulationPaused = false;
      let entrySelector, exitSelector, startStopButton, resetButton, clearHeatmapButton;

      let legendCanvas;
      let corridorType = "single";

      // Add global variables for desk tracking
      let deskInteractionCount = {};
      let totalDeskInteractions = 0;

      // Add global variables for statistics
      let desksInteracted = 0;
      let operatorsCompleted = 0;

      // Add global variables for frame control
      let lastFrameTime = 0;
      const FRAME_INTERVAL = 16; // ~60fps
      let isUpdating = false;

      function initializeDistanceMap() {
        // Initialize distance map with Infinity
        distanceMap = Array(gridHeight).fill().map(() => Array(gridWidth).fill(Infinity));
        
        // Find the closest valid point to the entry point
        let entryX = operatorSource.x;
        let entryY = Math.max(0, Math.min(gridHeight - 1, operatorSource.y + 1));
        
        // Set entry point distance to 0
        let queue = [{x: entryX, y: entryY, distance: 0}];
        distanceMap[entryY][entryX] = 0;
        
        while (queue.length > 0) {
          // Sort queue to process closest points first
          queue.sort((a, b) => a.distance - b.distance);
          let current = queue.shift();
          
          let moves = [
            {x: current.x + 1, y: current.y},
            {x: current.x - 1, y: current.y},
            {x: current.x, y: current.y + 1},
            {x: current.x, y: current.y - 1}
          ];
          
          for (let move of moves) {
            if (move.x >= 0 && move.x < gridWidth && 
                move.y >= 0 && move.y < gridHeight && 
                grid[move.y][move.x] !== 1) {
              let newDistance = current.distance + 1;
              if (newDistance < distanceMap[move.y][move.x]) {
                distanceMap[move.y][move.x] = newDistance;
                queue.push({x: move.x, y: move.y, distance: newDistance});
              }
            }
          }
        }
      }

      function isValidMove(x, y, agent) {
        // Basic boundary check
        if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) {
          return false;
        }

        // Check if the move would put us in a desk
        if (grid[y][x] === 1) {
          // Allow if it's the agent's assigned desk
          if (agent && agent.assignedDesk) {
            // Check if this position is within 1 cell of the assigned desk
            const deskDx = Math.abs(x - agent.assignedDesk.x);
            const deskDy = Math.abs(y - agent.assignedDesk.y);
            return deskDx <= 1 && deskDy <= 1;
          }
          return false;
        }

        // Check for other agents
        for (let other of operatorAgents) {
          if (other === agent || other.hasExited) continue;
          
          // Direct collision check
          if (other.x === x && other.y === y) {
            // Allow crossing paths if both agents are moving
            if (agent && agent.prevX !== undefined && agent.prevY !== undefined &&
                other.prevX !== undefined && other.prevY !== undefined) {
              let agentDx = x - agent.prevX;
              let agentDy = y - agent.prevY;
              let otherDx = other.x - other.prevX;
              let otherDy = other.y - other.prevY;
              
              // Allow crossing if moving in different directions
              if ((agentDx !== otherDx || agentDy !== otherDy) && 
                  !other.isInteracting) {
                return true;
              }
            }
            return false;
          }
        }

        return true;
      }

      function findNextMove(agent) {
        // Store previous position for crossing detection
        agent.prevX = agent.x;
        agent.prevY = agent.y;

        // Check if agent has valid assigned desk
        if (!agent.assignedDesk) {
          agent.hasExited = true;
          return null;
        }

        // Handle interaction with assigned desk
        if (!agent.hasInteracted) {
          // Check if near assigned desk
          const dx = Math.abs(agent.x - agent.assignedDesk.x);
          const dy = Math.abs(agent.y - agent.assignedDesk.y);
          
          // Only interact if this is the agent's assigned desk
          if (dx <= 1 && dy <= 1) {
            let deskOccupied = false;
            for (let other of operatorAgents) {
              if (other === agent || other.hasExited) continue;
              if (other.isInteracting && other.assignedDeskNumber === agent.assignedDeskNumber) {
                deskOccupied = true;
                break;
              }
            }
            
            if (!deskOccupied) {
              if (!agent.isInteracting) {
                agent.isInteracting = true;
                agent.interactionTime = 0;
              } else {
                agent.interactionTime++;
                if (agent.interactionTime >= 60) { // 1 second at 60fps
                  agent.isInteracting = false;
                  agent.hasInteracted = true;
                  desksInteracted++;
                  updateStatistics();
                }
              }
              return null;
            }
          }
          
          // If not at assigned desk, move towards it
          return findPathWithDijkstra(agent, agent.assignedDesk);
        }

        // After interaction, move to exit
        if (agent.hasInteracted) {
          // Calculate path to exit based on exit point location
          let targetX = operatorExit.x;
          let targetY = operatorExit.y;
          
          // Adjust target based on exit point location
          if (operatorExit.y === -1) targetY = 0;
          else if (operatorExit.y === gridHeight) targetY = gridHeight - 1;
          else if (operatorExit.x === -1) targetX = 0;
          else if (operatorExit.x === gridWidth) targetX = gridWidth - 1;
          
          // Check if reached exit vicinity
          if ((operatorExit.x === -1 && agent.x === 0) ||
              (operatorExit.x === gridWidth && agent.x === gridWidth - 1) ||
              (operatorExit.y === -1 && agent.y === 0) ||
              (operatorExit.y === gridHeight && agent.y === gridHeight - 1)) {
            agent.hasExited = true;
            operatorsCompleted++;
            updateStatistics();
            return null;
          }

          // Try normal pathfinding to exit
          return findPathWithDijkstra(agent, {x: targetX, y: targetY});
        }

        return null;
      }

      function findPathWithDijkstra(agent, target) {
        let queue = [{x: agent.x, y: agent.y, cost: 0, path: []}];
        let visited = new Set();
        let maxIterations = 1000;
        let iterations = 0;
        
        // Add randomness to break symmetry
        const randomOffset = Math.random() * 0.2;
        
        while (queue.length > 0 && iterations < maxIterations) {
          iterations++;
          
          // Sort by cost with small random factor
          queue.sort((a, b) => {
            let costA = a.cost + Math.random() * 0.1;
            let costB = b.cost + Math.random() * 0.1;
            
            // Add higher cost for positions near non-assigned desks
            if (agent && !agent.hasInteracted) {
              for (let desk of deskPositions) {
                if (desk === agent.assignedDesk) continue;
                let distA = Math.abs(a.x - desk.x) + Math.abs(a.y - desk.y);
                let distB = Math.abs(b.x - desk.x) + Math.abs(b.y - desk.y);
                if (distA <= 2) costA += 10;
                if (distB <= 2) costB += 10;
              }
            }
            
            return costA - costB;
          });
          
          let current = queue.shift();
          
          let key = `${current.x},${current.y}`;
          if (visited.has(key)) continue;
          visited.add(key);
          
          // Check if we've reached the target
          if (Math.abs(current.x - target.x) <= 1 && Math.abs(current.y - target.y) <= 1) {
            if (current.path.length === 0) {
              // If already at target, find best adjacent cell
              let bestMove = null;
              let bestCost = Infinity;
              
              for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                  if (dx === 0 && dy === 0) continue;
                  
                  let newX = current.x + dx;
                  let newY = current.y + dy;
                  
                  if (!isValidMove(newX, newY, agent)) continue;
                  
                  let cost = Math.abs(newX - target.x) + Math.abs(newY - target.y);
                  
                  // Add cost for proximity to other agents
                  for (let other of operatorAgents) {
                    if (other === agent || other.hasExited) continue;
                    let dist = Math.sqrt(Math.pow(newX - other.x, 2) + Math.pow(newY - other.y, 2));
                    if (dist < 3) cost += (3 - dist) * 2;
                  }
                  
                  // Add high cost for positions near non-assigned desks
                  if (!agent.hasInteracted) {
                    for (let desk of deskPositions) {
                      if (desk === agent.assignedDesk) continue;
                      let dist = Math.abs(newX - desk.x) + Math.abs(newY - desk.y);
                      if (dist <= 2) cost += 10;
                    }
                  }
                  
                  if (cost < bestCost) {
                    bestCost = cost;
                    bestMove = {x: newX, y: newY};
                  }
                }
              }
              
              if (bestMove) return bestMove;
            }
            return current.path[0] || {x: current.x, y: current.y};
          }
          
          // Define possible moves including diagonals
          let moves = [
            {x: 1, y: 0}, {x: -1, y: 0}, {x: 0, y: 1}, {x: 0, y: -1},
            {x: 1, y: 1}, {x: -1, y: 1}, {x: 1, y: -1}, {x: -1, y: -1}
          ];
          
          // Shuffle moves
          for (let i = moves.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [moves[i], moves[j]] = [moves[j], moves[i]];
          }
          
          for (let move of moves) {
            let newX = current.x + move.x;
            let newY = current.y + move.y;
            
            let tempAgent = {...agent, prevX: current.x, prevY: current.y};
            if (!isValidMove(newX, newY, tempAgent)) continue;
            
            let newCost = current.cost + 1;
            
            // Add cost for moving away from target
            let targetDist = Math.abs(newX - target.x) + Math.abs(newY - target.y);
            newCost += targetDist * 0.5;
            
            // Add cost for proximity to other agents
            for (let other of operatorAgents) {
              if (other === agent || other.hasExited) continue;
              let dist = Math.sqrt(Math.pow(newX - other.x, 2) + Math.pow(newY - other.y, 2));
              if (dist < 3) newCost += (3 - dist) * 2;
            }
            
            // Add high cost for proximity to non-assigned desks
            if (!agent.hasInteracted) {
              for (let desk of deskPositions) {
                if (desk === agent.assignedDesk) continue;
                let dist = Math.abs(newX - desk.x) + Math.abs(newY - desk.y);
                if (dist <= 2) newCost += 10;
              }
            }
            
            // Add small random cost
            newCost += Math.random() * randomOffset;
            
            let newPath = [...current.path];
            if (newPath.length === 0) {
              newPath.push({x: newX, y: newY});
            }
            
            queue.push({
              x: newX,
              y: newY,
              cost: newCost,
              path: newPath
            });
          }
        }
        
        // If no path found, try to move towards target while avoiding obstacles
        let dx = target.x - agent.x;
        let dy = target.y - agent.y;
        
        // Create prioritized list of moves
        let preferredMoves = [];
        
        // Add moves based on target direction
        if (Math.abs(dx) > Math.abs(dy)) {
          preferredMoves.push({x: Math.sign(dx), y: 0});
          preferredMoves.push({x: Math.sign(dx), y: Math.sign(dy)});
          preferredMoves.push({x: 0, y: Math.sign(dy)});
        } else {
          preferredMoves.push({x: 0, y: Math.sign(dy)});
          preferredMoves.push({x: Math.sign(dx), y: Math.sign(dy)});
          preferredMoves.push({x: Math.sign(dx), y: 0});
        }
        
        // Add alternative moves
        preferredMoves.push({x: -Math.sign(dx), y: Math.sign(dy)});
        preferredMoves.push({x: Math.sign(dx), y: -Math.sign(dy)});
        
        // Try each preferred move
        for (let move of preferredMoves) {
          let newX = agent.x + move.x;
          let newY = agent.y + move.y;
          let tempAgent = {...agent, prevX: agent.x, prevY: agent.y};
          
          if (isValidMove(newX, newY, tempAgent)) {
            return {x: newX, y: newY};
          }
        }
        
        return null;
      }

      function calculateMoveCost(x, y, agent) {
        let baseCost = 1;
        
        // Add cost for proximity to furniture
        for (let dy = -2; dy <= 2; dy++) {
          for (let dx = -2; dx <= 2; dx++) {
            let checkX = x + dx;
            let checkY = y + dy;
            if (checkX >= 0 && checkX < gridWidth && 
                checkY >= 0 && checkY < gridHeight && 
                grid[checkY][checkX] === 1) {
              let distance = Math.sqrt(dx * dx + dy * dy);
              baseCost += 2 / (distance + 1);
            }
          }
        }
        
        // Add cost for proximity to other agents
        for (let other of operatorAgents) {
          if (other === agent) continue;
          let dx = x - other.x;
          let dy = y - other.y;
          let distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < 3) {
            baseCost += 3 / (distance + 1);
          }
        }
        
        return baseCost;
      }

      function calculateMaxDesks() {
        // Get current division dimensions
        let numDivisions = divisions;
        let numRows, numCols;
        
        if (numDivisions === 2) {
          numRows = 1;
          numCols = 2;
        } else if (numDivisions === 9) {
          numRows = 3;
          numCols = 3;
        } else {
          numRows = 2;
          numCols = 2;
        }

        if (corridorType === 'double') {
          if (arrangement === 'row') {
            switch(numDivisions) {
              case 2:
                return 88; // 44 desks per division
              case 4:
                return 80; // 20 desks per division
              case 9:
                return 54; // 6 desks per division
              default:
                return 0;
            }
          } else if (arrangement === 'column') {
            switch(numDivisions) {
              case 2:
                return 90; // 45 desks per division
              case 4:
                return 80; // 20 desks per division
              case 9:
                return 54; // 6 desks per division
              default:
                return 0;
            }
          }
        } else {
          // Calculate path and division sizes
          const pathWidth = 6; // 6ft yellow path
          const totalUsableWidth = gridWidth - (pathWidth * (numCols - 1));
          const totalUsableHeight = gridHeight - (pathWidth * (numRows - 1));
          const divWidth = Math.floor(totalUsableWidth / numCols);
          const divHeight = Math.floor(totalUsableHeight / numRows);

          let maxDesksPerDivision = 0;

          if (arrangement === 'row') {
            // For row arrangement
            const deskWidth = 6; // 6ft wide
            const deskHeight = 2; // 2ft deep
            const minSpacing = 6; // Minimum 6ft between rows

            // Calculate desks per row
            const desksPerRow = Math.floor(divWidth / deskWidth);
            
            // Calculate total rows with proper spacing
            const totalRows = Math.floor((divHeight + minSpacing) / (deskHeight + minSpacing));
            
            maxDesksPerDivision = desksPerRow * totalRows;
          } else if (arrangement === 'column') {
            // For column arrangement
            const deskWidth = 2; // 2ft wide
            const deskHeight = 6; // 6ft deep
            const minSpacing = 6; // Minimum 6ft between columns

            // Calculate desks per column
            const desksPerColumn = Math.floor(divHeight / deskHeight);
            
            // Calculate total columns with proper spacing
            const totalColumns = Math.floor((divWidth + minSpacing) / (deskWidth + minSpacing));
            
            maxDesksPerDivision = desksPerColumn * totalColumns;
          }

          return maxDesksPerDivision * numDivisions;
        }
      }

      function updateSliderLimits() {
        const maxPossibleDesks = calculateMaxDesks();
        // Round down to nearest multiple of divisions
        const maxDesks = Math.floor(maxPossibleDesks / divisions) * divisions;
        
        // Update slider attributes
        desksSlider.max = maxDesks;
        desksSlider.step = divisions;
        
        // If current value exceeds new max, adjust it
        let currentValue = parseInt(desksSlider.value);
        if (currentValue > maxDesks) {
          currentValue = maxDesks;
        } else {
          // Ensure current value is a multiple of divisions
          currentValue = Math.floor(currentValue / divisions) * divisions;
        }
        
        desksSlider.value = currentValue;
        desks = currentValue;
        document.getElementById('desks-value').textContent = currentValue;
        
        // Update slider appearance
        const percentage = (currentValue / maxDesks) * 100;
        desksSlider.style.background = `linear-gradient(to right, 
          #000000 ${percentage}%, 
          #cccccc ${percentage}%)`;
      }

      function setup() {
        // Calculate the available space
        let availableWidth = windowWidth - 600;
        let availableHeight = windowHeight;
        
        // Use a single uniform margin for all sides
        cellSize = Math.floor(Math.min(
          (availableWidth - uniformMargin * 2) / gridWidth,
          (availableHeight - uniformMargin * 2) / gridHeight
        ));
        
        // Create canvas with the exact size needed for the grid plus margins
        let canvasWidth = gridWidth * cellSize + (uniformMargin * 2);
        let canvasHeight = gridHeight * cellSize + (uniformMargin * 2);
        let canvas = createCanvas(canvasWidth, canvasHeight, P2D);
        canvas.parent('simulation-container');
        frameRate(60);
        
        // Enable double buffering
        canvas.elt.style.imageRendering = 'pixelated';
        
        // Initialize grid and arrays
        grid = Array.from({ length: gridHeight }, () => Array(gridWidth).fill(0));
        deskPositions = [];
        operatorAgents = [];

        // Set default entry and exit positions
        setDefaultEntryExit();

        // Get references to HTML elements
        divisionsSlider = document.getElementById('divisions-slider');
        desksSlider = document.getElementById('desks-slider');
        arrangementSelector = document.getElementById('arrangement-selector');
        operatorsSlider = document.getElementById('operators-slider');
        speedSlider = document.getElementById('speed-slider');
        entrySelector = document.getElementById('entry-selector');
        exitSelector = document.getElementById('exit-selector');
        startStopButton = document.getElementById('start-stop-button');
        resetButton = document.getElementById('reset-button');
        clearHeatmapButton = document.getElementById('clear-heatmap-button');
        corridorTypeSelector = document.getElementById('corridor-type-selector');

        // Set default values
        divisionsSlider.value = 1; // Set to 2 divisions (value 1 corresponds to 2 divisions)
        divisions = 2;
        document.getElementById('divisions-value').textContent = divisions;

        // Update slider limits and get max desks
        updateSliderLimits();
        let maxDesks = parseInt(desksSlider.max);
        desksSlider.value = maxDesks;
        desks = maxDesks;
        document.getElementById('desks-value').textContent = maxDesks;

        // Set operators to match number of desks exactly
        operatorsSlider.value = maxDesks;
        document.getElementById('operators-value').textContent = maxDesks;

        // Set speed to maximum
        speedSlider.value = 10;
        operatorSpeed = 10;
        document.getElementById('speed-value').textContent = 10;

        // Update slider appearances
        desksSlider.style.background = `linear-gradient(to right, #000000 100%, #cccccc 100%)`;
        operatorsSlider.style.background = `linear-gradient(to right, #000000 100%, #cccccc 100%)`;
        speedSlider.style.background = `linear-gradient(to right, #000000 100%, #cccccc 100%)`;

        // Initialize frame timing
        lastFrameTime = performance.now();

        let isUpdating = false;
        let updatePending = false;

        // Function to update values without triggering redraws
        function updateValues() {
          if (isUpdating) {
            updatePending = true;
            return;
          }
          
          isUpdating = true;
          
          // Update divisions
          let sliderValue = parseInt(divisionsSlider.value);
          if (sliderValue === 1) divisions = 2;
          else if (sliderValue === 2) divisions = 4;
          else if (sliderValue === 3) divisions = 9;
          document.getElementById('divisions-value').textContent = divisions;
          
          // Update slider limits based on new division count
          updateSliderLimits();
          
          isUpdating = false;
          
          if (updatePending) {
            updatePending = false;
            requestAnimationFrame(updateValues);
          }
        }

        // Modify the throttled redraw function
        const throttledRedraw = throttle(() => {
          // Only update grid and redraw if simulation is paused
          if (isSimulationPaused) {
            placeDesksInDivisions();
            clear();
            push();
            translate(uniformMargin, uniformMargin);
            drawGrid();
            drawDivisions();
            drawDesks();
            drawHeatMap();
            drawEntryExitPoints();
            pop();
          }
        }, 16); // ~60fps

        // Delayed full reset
        const delayedReset = throttle(() => {
        resetSimulation();
        }, 250);

        // Update event listeners
        divisionsSlider.addEventListener('input', () => {
          if (!isSimulationPaused) return;
          updateValues();
          throttledRedraw();
        });

        divisionsSlider.addEventListener('change', delayedReset);

        desksSlider.addEventListener('input', () => {
          if (!isSimulationPaused) return;
          
          // Ensure value is a multiple of divisions
          let newValue = parseInt(desksSlider.value);
          newValue = Math.floor(newValue / divisions) * divisions;
          
          // Update slider value and display
          desksSlider.value = newValue;
          desks = newValue;
          document.getElementById('desks-value').textContent = newValue;
          
          // Update slider appearance
          const maxDesks = parseInt(desksSlider.max);
          const percentage = (newValue / maxDesks) * 100;
          desksSlider.style.background = `linear-gradient(to right, 
            #000000 ${percentage}%, 
            #cccccc ${percentage}%)`;
          
          throttledRedraw();
        });

        desksSlider.addEventListener('change', delayedReset);

        arrangementSelector.addEventListener('change', () => {
          arrangement = arrangementSelector.value;
          updateSliderLimits();
          throttledRedraw();
          delayedReset();
        });

        operatorsSlider.addEventListener('input', () => {
          let opCount = parseInt(operatorsSlider.value);
          document.getElementById('operators-value').textContent = opCount;
          throttledRedraw();
        });

        operatorsSlider.addEventListener('change', delayedReset);

        corridorTypeSelector.addEventListener('change', () => {
          corridorType = corridorTypeSelector.value;
          updateSliderLimits();
          throttledRedraw();
          delayedReset();
        });

        speedSlider.addEventListener('input', () => {
          operatorSpeed = speedSlider.value;
          document.getElementById('speed-value').textContent = operatorSpeed;
        });

        // Setup legend canvas with proper dimensions
        let legendElement = document.getElementById('legend-canvas');
        let rect = legendElement.getBoundingClientRect();
        legendCanvas = createGraphics(rect.width, rect.height);
        legendElement.width = rect.width;
        legendElement.height = rect.height;

        // Add event listeners for entry/exit selectors
        entrySelector.addEventListener('change', () => {
          placementMode = entrySelector.value === 'set' ? 'entry' : 'default';
          if (placementMode === 'default') {
            setDefaultEntry();
            initializeDistanceMap();
          }
        });

        exitSelector.addEventListener('change', () => {
          placementMode = exitSelector.value === 'set' ? 'exit' : 'default';
          if (placementMode === 'default') {
            setDefaultExit();
            initializeDistanceMap();
          }
        });

        startStopButton.addEventListener('click', () => {
          isSimulationPaused = !isSimulationPaused;
          startStopButton.textContent = isSimulationPaused ? 'Start' : 'Stop';
        });

        resetButton.addEventListener('click', resetSimulation);

        clearHeatmapButton.addEventListener('click', () => {
          globalHeatMap = {};
          maxVisits = 0;
          drawHeatMapLegend();
        });

        // Place desks in divisions
        placeDesksInDivisions();

        // Initialize distance map for pathfinding
        initializeDistanceMap();

        // Start simulation in paused state
        isSimulationPaused = true;
        startStopButton.textContent = 'Start';
        
        // Initialize operators
        let opCount = parseInt(operatorsSlider.value) || 0;
        for (let i = 0; i < opCount; i++) {
          operatorAgents.push({
            x: Math.max(0, Math.min(gridWidth - 1, operatorSource.x)),
            y: Math.max(0, Math.min(gridHeight - 1, operatorSource.y + 1)),
            startX: operatorSource.x,
            startY: operatorSource.y,
            visited: new Set(),
            pathColor: color(random(100, 255), random(100), random(100), 150),
            targetDesk: null,
            desksVisited: 0,
            isExiting: false,
            hasExited: false,
            visitedDesks: new Set(),
            interactionTime: 0,
            isInteracting: false,
            prevX: operatorSource.x,
            prevY: operatorSource.y
          });
        }

        // Clear and redraw the heat map legend
        drawHeatMapLegend();
        
        // Force immediate redraw to show initial state
        draw();

        // Initial update of slider limits
        updateSliderLimits();

        // Update statistics for initial state
        updateStatistics();
      }

      function setDefaultEntryExit() {
        // Set default entry and exit positions (middle of top and bottom edges)
        operatorSource = { 
          x: Math.floor(gridWidth / 2), // Middle of top edge
          y: -1 // Outside the grid at the top
        };
        
        operatorExit = { 
          x: Math.floor(gridWidth / 2), // Middle of bottom edge
          y: gridHeight // Outside the grid at the bottom
        };
      }

      function setDefaultEntry() {
        operatorSource = { 
          x: Math.floor(gridWidth / 2), // Middle of top edge
          y: -1 // Outside the grid at the top
        };
      }

      function setDefaultExit() {
        operatorExit = { 
          x: Math.floor(gridWidth / 2), // Middle of bottom edge
          y: gridHeight // Outside the grid at the bottom
        };
      }

      function windowResized() {
        // Calculate the available space
        let availableWidth = windowWidth - 600;
        let availableHeight = windowHeight;
        
        // Calculate cell size to fit the entire studio
        let newCellSize = Math.floor(Math.min(
          (availableWidth - uniformMargin * 2) / gridWidth,
          (availableHeight - uniformMargin * 2) / gridHeight
        ));
        
        // Only resize if cell size has actually changed
        if (newCellSize !== cellSize) {
          cellSize = newCellSize;
          
          // Resize canvas with uniform margins
          let canvasWidth = gridWidth * cellSize + (uniformMargin * 2);
          let canvasHeight = gridHeight * cellSize + (uniformMargin * 2);
          resizeCanvas(canvasWidth, canvasHeight, true);
          
          // Force immediate redraw
          placeDesksInDivisions();
          draw();
        }
      }

      function draw() {
        background(255);

        // Add translation to center the grid with uniform margins
        translate(uniformMargin, uniformMargin);

        drawGrid();
        drawDivisions();
        drawDesks();
        drawHeatMap();
        drawHeatMapLegend();
        drawEntryExitPoints();

        // Update and draw operators
        if (!isSimulationPaused) {
        updateOperators();
        } else {
          // When paused, just redraw current operator positions
          for (let agent of operatorAgents) {
            if (agent.isInteracting) {
              fill(200);  // Grey for interacting operators
            } else if (agent.hasInteracted) {
              // Find closest distance to any other operator for base color
              let minDistance = Infinity;
              for (let other of operatorAgents) {
                if (other === agent || other.hasExited || other.isInteracting) continue;
                const dx = Math.abs(agent.x - other.x);
                const dy = Math.abs(agent.y - other.y);
                const distance = Math.sqrt(dx * dx + dy * dy);
                minDistance = Math.min(minDistance, distance);
              }

              // Set base color based on distance
              if (minDistance <= 1) {
                fill(255, 0, 0);  // Red for unsafe distance (<1ft)
              } else if (minDistance <= 3) {
                fill(255, 255, 0);  // Yellow for warning distance (2-3ft)
              } else {
                fill(0, 255, 0);  // Green for safe distance (>4ft)
              }
              
              // Add thick black stroke for exiting operators
              stroke(0);
              strokeWeight(3);
            } else {
              // Find closest distance to any other operator
              let minDistance = Infinity;
              for (let other of operatorAgents) {
                if (other === agent || other.hasExited || other.isInteracting) continue;
                const dx = Math.abs(agent.x - other.x);
                const dy = Math.abs(agent.y - other.y);
                const distance = Math.sqrt(dx * dx + dy * dy);
                minDistance = Math.min(minDistance, distance);
              }

              // Set color based on distance
              if (minDistance <= 1) {
                fill(255, 0, 0);  // Red for unsafe distance (<1ft)
              } else if (minDistance <= 3) {
                fill(255, 255, 0);  // Yellow for warning distance (2-3ft)
              } else {
                fill(0, 255, 0);  // Green for safe distance (>4ft)
              }
              stroke(0);
              strokeWeight(1);
            }
            
            // Draw operator
            ellipse(agent.x * cellSize + cellSize/2, agent.y * cellSize + cellSize/2, cellSize * 0.8, cellSize * 0.8);
            
            // Add verification tick for exiting operators
            if (agent.hasInteracted) {
              push();
              translate(agent.x * cellSize + cellSize/2, agent.y * cellSize + cellSize/2);
              stroke(0);
              strokeWeight(2);
              noFill();
              // Draw check mark
              beginShape();
              vertex(-cellSize * 0.2, 0);
              vertex(0, cellSize * 0.2);
              vertex(cellSize * 0.2, -cellSize * 0.2);
              endShape();
              pop();
            }
          }
        }
      }

      function mousePressed() {
        if (placementMode === 'entry' || placementMode === 'exit') {
          // Convert mouse coordinates to grid coordinates, accounting for translation
          let gridX = Math.floor((mouseX - uniformMargin) / cellSize);
          let gridY = Math.floor((mouseY - uniformMargin) / cellSize);
          
          // Check if click is on any edge of the grid
          let isOnEdge = (
            (gridY === -1 && gridX >= 0 && gridX < gridWidth) || // Top edge
            (gridY === gridHeight && gridX >= 0 && gridX < gridWidth) || // Bottom edge
            (gridX === -1 && gridY >= 0 && gridY < gridHeight) || // Left edge
            (gridX === gridWidth && gridY >= 0 && gridY < gridHeight) // Right edge
          );
          
          if (isOnEdge) {
            if (placementMode === 'entry') {
              operatorSource = { x: gridX, y: gridY };
            } else if (placementMode === 'exit') {
              operatorExit = { x: gridX, y: gridY };
            }
            // Reset placement mode to default after placing a point
            placementMode = 'default';
            document.querySelector('select').value = 'default';
            // Reinitialize distance map for new entry point
            initializeDistanceMap();
          }
        }
      }

      function resetSimulation() {
        // Reset grid and positions
        grid = Array.from({ length: gridHeight }, () => Array(gridWidth).fill(0));
        deskPositions = [];
        operatorAgents = [];

        // Reset statistics
        desksInteracted = 0;
        operatorsCompleted = 0;
        updateStatistics();

        // Clear heat map and trails
        globalHeatMap = {};
        maxVisits = 0;
        
        // Start in paused state
        isSimulationPaused = true;  
        startStopButton.textContent = 'Start';
        
        // Place desks in divisions
        placeDesksInDivisions();

        // Initialize new operators at the current entry point
        let spawnPoint = findValidSpawnPoint();
        if (spawnPoint && deskPositions.length > 0) {
          // Create a shuffled array of desk indices for random assignment
          let deskIndices = Array.from({length: deskPositions.length}, (_, i) => i);
          for (let i = deskIndices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deskIndices[i], deskIndices[j]] = [deskIndices[j], deskIndices[i]];
          }

          // Get the current operator count from the slider
          let opCount = parseInt(operatorsSlider.value);
          // Ensure we don't create more operators than desks
          opCount = Math.min(opCount, deskPositions.length);

          // Create operators with assigned desks
        for (let i = 0; i < opCount; i++) {
            let assignedDesk = deskPositions[deskIndices[i]];
            if (assignedDesk) {
              operatorAgents.push({
                x: spawnPoint.x,
                y: spawnPoint.y,
                startX: spawnPoint.x,
                startY: spawnPoint.y,
                visited: new Set(),
                pathColor: color(random(100, 255), random(100), random(100), 150),
                assignedDesk: assignedDesk,
                assignedDeskNumber: assignedDesk.number, // Store the desk number
                hasInteracted: false,
                isExiting: false,
                hasExited: false,
                visitedDesks: new Set(),
                interactionTime: 0,
                isInteracting: false,
                prevX: spawnPoint.x,
                prevY: spawnPoint.y
              });
            }
          }
        }

        // Update area statistics
        calculateAreas();
        
        // Force immediate redraw to show initial state
        draw();
      }

      function placeDesksInDivisions() {
        // Calculate division dimensions
        let numDivisions = divisions;
        let numRows, numCols;
        
        // Special handling for 2 divisions
        if (numDivisions === 2) {
          numRows = 1;
          numCols = 2;
        } else if (numDivisions === 9) {
          numRows = 3;
          numCols = 3;
        } else {
          numRows = 2;
          numCols = 2;
        }

        // Initialize grid
        grid = Array(gridHeight).fill().map(() => Array(gridWidth).fill(0));
        deskPositions = [];

        // Calculate path and division sizes
        const pathWidth = 6; // 6ft yellow path
        const totalUsableWidth = gridWidth - (pathWidth * (numCols - 1)); // Total width minus paths
        const totalUsableHeight = gridHeight - (pathWidth * (numRows - 1)); // Total height minus paths
        const divWidth = Math.floor(totalUsableWidth / numCols);
        const divHeight = Math.floor(totalUsableHeight / numRows);

        // Calculate desks per division
        let desksPerDivision = Math.floor(desks / numDivisions);
        let remainingDesks = desks % numDivisions;

        // Place desks division by division
        let currentDiv = 0;
        for (let row = 0; row < numRows && currentDiv < numDivisions; row++) {
          for (let col = 0; col < numCols && currentDiv < numDivisions; col++) {
            // Calculate division boundaries accounting for yellow paths
            let divStartX = col * (divWidth + pathWidth);
            let divStartY = row * (divHeight + pathWidth);
            let divEndX = divStartX + divWidth;
            let divEndY = divStartY + divHeight;

            // Calculate desks for this division
            let divisionDesks = desksPerDivision + (currentDiv < remainingDesks ? 1 : 0);

            if (arrangement === 'row' && corridorType === 'double') {
              // Calculate desk dimensions
              const deskWidth = 6; // 6ft wide
              const deskHeight = 2; // 2ft tall
              const rowSpacing = 6; // 6ft between single rows
              const pairSpacing = 8; // 8ft total spacing (2ft desk + 6ft clear space) between pairs
              
              // Calculate max desks in a row
              const maxDesksInRow = Math.floor(divWidth / deskWidth);
              
              // Calculate number of rows that can fit with proper spacing
              const maxRows = Math.floor((divHeight + rowSpacing) / (deskHeight + pairSpacing));
              
              // Calculate total space needed for desks in a row
              let totalDeskWidth = Math.min(divisionDesks, maxDesksInRow) * deskWidth;
              
              // Center the desk block horizontally in the division
              let startX = divStartX + Math.floor((divWidth - totalDeskWidth) / 2);
              
              let currentDesk = 0;
              
              // Place desks row by row
              for (let rowPos = 0; rowPos < maxRows && currentDesk < divisionDesks; rowPos++) {
                // Calculate Y position based on whether previous row was a pair
                let prevWasPair = rowPos > 0 && grid[Math.floor(divStartY + (rowPos - 1) * (deskHeight + pairSpacing) + deskHeight)][startX] === 1;
                let rowY;
                
                if (rowPos === 0) {
                    rowY = divStartY; // First row starts at division start
                } else if (prevWasPair) {
                    rowY = divStartY + rowPos * (deskHeight + pairSpacing); // After a pair, use pair spacing
                } else {
                    rowY = divStartY + (rowPos - 1) * (deskHeight + pairSpacing) + deskHeight + rowSpacing; // After single row, use row spacing
                }

                let canPair = true;
                
                // Check if this row touches a boundary or path
                if (rowY <= divStartY) canPair = false; // Top edge
                if (rowY + deskHeight >= divEndY) canPair = false; // Bottom edge
                if (row > 0 && rowY <= divStartY + deskHeight) canPair = false; // Near top path
                if (row < numRows - 1 && rowY + deskHeight >= divEndY - deskHeight) canPair = false; // Near bottom path
                
                // Place desks in this row
                for (let col = 0; col < maxDesksInRow && currentDesk < divisionDesks; col++) {
                  let deskX = startX + (col * deskWidth);
                  
                  // Place first desk
                  if (deskX >= divStartX && (deskX + deskWidth) <= divEndX &&
                      rowY >= divStartY && (rowY + deskHeight) <= divEndY) {
                    for (let y = 0; y < deskHeight; y++) {
                      for (let x = 0; x < deskWidth; x++) {
                        let gridX = deskX + x;
                        let gridY = rowY + y;
                        if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {
                          grid[gridY][gridX] = 1;
                        }
                      }
                    }
                    deskPositions.push({x: deskX, y: rowY});
                    currentDesk++;
                  }
                  
                  // Place paired desk if allowed and needed
                  if (canPair && currentDesk < divisionDesks) {
                    let pairedY = rowY + deskHeight;
                    if (pairedY >= divStartY && (pairedY + deskHeight) <= divEndY) {
                      for (let y = 0; y < deskHeight; y++) {
                        for (let x = 0; x < deskWidth; x++) {
                          let gridX = deskX + x;
                          let gridY = pairedY + y;
                          if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {
                            grid[gridY][gridX] = 1;
                          }
                        }
                      }
                      deskPositions.push({x: deskX, y: pairedY});
                      currentDesk++;
                    }
                  }
                }
              }
            } else if (arrangement === 'column' && corridorType === 'double') {
              // Calculate desk dimensions
              const deskWidth = 2; // 2ft wide
              const deskHeight = 6; // 6ft tall
              const colSpacing = 6; // 6ft between single columns
              const pairSpacing = 8; // 8ft total spacing (2ft desk + 6ft clear space) between pairs
              
              // Calculate max desks in a column
              const maxDesksInCol = Math.floor(divHeight / deskHeight);
              
              // Calculate number of columns that can fit with proper spacing
              const maxCols = Math.floor((divWidth + colSpacing) / (deskWidth + pairSpacing));
              
              // Calculate total space needed for desks in a column
              let totalDeskHeight = Math.min(divisionDesks, maxDesksInCol) * deskHeight;
              
              // Center the desk block vertically in the division
              let startY = divStartY + Math.floor((divHeight - totalDeskHeight) / 2);
              
              let currentDesk = 0;
              
              // Place desks column by column
              for (let colPos = 0; colPos < maxCols && currentDesk < divisionDesks; colPos++) {
                // Calculate X position based on whether previous column was a pair
                let prevWasPair = colPos > 0 && grid[startY][Math.floor(divStartX + (colPos - 1) * (deskWidth + pairSpacing) + deskWidth)] === 1;
                let colX;
                
                if (colPos === 0) {
                    colX = divStartX; // First column starts at division start
                } else if (prevWasPair) {
                    colX = divStartX + colPos * (deskWidth + pairSpacing); // After a pair, use pair spacing
                } else {
                    colX = divStartX + (colPos - 1) * (deskWidth + pairSpacing) + deskWidth + colSpacing; // After single column, use column spacing
                }

                let canPair = true;
                
                // Check if this column touches a boundary or path
                if (colX <= divStartX) canPair = false; // Left edge
                if (colX + deskWidth >= divEndX) canPair = false; // Right edge
                if (col > 0 && colX <= divStartX + deskWidth) canPair = false; // Near left path
                if (col < numCols - 1 && colX + deskWidth >= divEndX - deskWidth) canPair = false; // Near right path
                
                // Place desks in this column
                for (let row = 0; row < maxDesksInCol && currentDesk < divisionDesks; row++) {
                  let deskY = startY + (row * deskHeight);
                  
                  // Place first desk
                  if (colX >= divStartX && (colX + deskWidth) <= divEndX &&
                      deskY >= divStartY && (deskY + deskHeight) <= divEndY) {
                    for (let y = 0; y < deskHeight; y++) {
                      for (let x = 0; x < deskWidth; x++) {
                        let gridX = colX + x;
                        let gridY = deskY + y;
                        if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {
                          grid[gridY][gridX] = 1;
                        }
                      }
                    }
                    deskPositions.push({x: colX, y: deskY});
                    currentDesk++;
                  }
                  
                  // Place paired desk if allowed and needed
                  if (canPair && currentDesk < divisionDesks) {
                    let pairedX = colX + deskWidth;
                    if (pairedX >= divStartX && (pairedX + deskWidth) <= divEndX) {
                      for (let y = 0; y < deskHeight; y++) {
                        for (let x = 0; x < deskWidth; x++) {
                          let gridX = pairedX + x;
                          let gridY = deskY + y;
                          if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {
                            grid[gridY][gridX] = 1;
                          }
                        }
                      }
                      deskPositions.push({x: pairedX, y: deskY});
                      currentDesk++;
                    }
                  }
                }
              }
            } else if (arrangement === 'row') {
              // Single-loaded row arrangement
              // Calculate desk dimensions
              let deskWidth = 6; // 6ft wide
              let deskHeight = 2; // 2ft tall
              
              // Calculate how many desks can fit in a row
              let maxDesksInRow = Math.floor(divWidth / deskWidth);
              let rowsNeeded = Math.ceil(divisionDesks / maxDesksInRow);
              
              // Calculate total space needed for desks
              let totalDeskWidth = Math.min(divisionDesks, maxDesksInRow) * deskWidth;
              let totalDeskHeight = rowsNeeded * (deskHeight + 6) - 6; // 6ft spacing between rows
              
              // Center the desk block in the division
              let startX = divStartX + Math.floor((divWidth - totalDeskWidth) / 2);
              let startY = divStartY + Math.floor((divHeight - totalDeskHeight) / 2);
              
              // Place desks in rows
              let currentDesk = 0;
              for (let deskRow = 0; deskRow < rowsNeeded && currentDesk < divisionDesks; deskRow++) {
                let rowDesks = Math.min(maxDesksInRow, divisionDesks - currentDesk);
                let rowWidth = rowDesks * deskWidth;
                let rowStartX = startX + Math.floor((totalDeskWidth - rowWidth) / 2);
                
                for (let deskCol = 0; deskCol < rowDesks; deskCol++) {
                  let deskX = rowStartX + deskCol * deskWidth;
                  let deskY = startY + deskRow * (deskHeight + 6);
                  
                  // Verify desk position is within division bounds and not in yellow path
                  if (deskX >= divStartX && (deskX + deskWidth) <= divEndX &&
                      deskY >= divStartY && (deskY + deskHeight) <= divEndY) {
                    // Place desk
                    for (let y = 0; y < deskHeight; y++) {
                      for (let x = 0; x < deskWidth; x++) {
                        let gridX = deskX + x;
                        let gridY = deskY + y;
                        if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {
                          grid[gridY][gridX] = 1;
                        }
                      }
                    }
                    deskPositions.push({x: deskX, y: deskY});
                    currentDesk++;
                  }
                }
              }
            } else if (arrangement === 'column') {
              // Single-loaded column arrangement
              // Calculate desk dimensions
              const deskWidth = 2; // 2ft wide
              const deskHeight = 6; // 6ft tall
              const colSpacing = 6; // 6ft between columns
              
              // Calculate max desks in a column
              const maxDesksInCol = Math.floor(divHeight / deskHeight);
              
              // Calculate number of columns needed
              const colsNeeded = Math.ceil(divisionDesks / maxDesksInCol);
              
              // Calculate total space needed for desks
              let totalDeskHeight = Math.min(divisionDesks, maxDesksInCol) * deskHeight;
              let totalDeskWidth = colsNeeded * (deskWidth + colSpacing) - colSpacing;
              
              // Center the desk block in the division
              let startX = divStartX + Math.floor((divWidth - totalDeskWidth) / 2);
              let startY = divStartY + Math.floor((divHeight - totalDeskHeight) / 2);
              
              // Place desks in columns
              let currentDesk = 0;
              for (let colPos = 0; colPos < colsNeeded && currentDesk < divisionDesks; colPos++) {
                let colDesks = Math.min(maxDesksInCol, divisionDesks - currentDesk);
                let colHeight = colDesks * deskHeight;
                let colStartY = startY + Math.floor((totalDeskHeight - colHeight) / 2);
                let colX = startX + colPos * (deskWidth + colSpacing);
                
                // Skip if column would be in a path
                if (colX < divStartX || colX + deskWidth > divEndX) continue;
                
                for (let row = 0; row < colDesks; row++) {
                  let deskY = colStartY + (row * deskHeight);
                  
                  // Verify desk position is within division bounds and not in yellow path
                  if (deskY >= divStartY && (deskY + deskHeight) <= divEndY) {
                    // Place desk
                    for (let y = 0; y < deskHeight; y++) {
                      for (let x = 0; x < deskWidth; x++) {
                        let gridX = colX + x;
                        let gridY = deskY + y;
                        if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {
                          grid[gridY][gridX] = 1;
                        }
                      }
                    }
                    deskPositions.push({x: colX, y: deskY});
                    currentDesk++;
                  }
                }
              }
            }
            currentDiv++;
          }
        }

        // Update area statistics after placing desks
        calculateAreas();
        
        // Update statistics after placing desks
        updateStatistics();
      }

      function drawGrid() {
        // Draw the main grid
        stroke(220);
        strokeWeight(0.5);
        
        // Draw vertical lines
        for (let x = 0; x <= gridWidth; x++) {
          line(x * cellSize, 0, x * cellSize, gridHeight * cellSize);
        }
        
        // Draw horizontal lines
        for (let y = 0; y <= gridHeight; y++) {
          line(0, y * cellSize, gridWidth * cellSize, y * cellSize);
        }

        // Draw thicker lines every 6 feet for better scale reference
        stroke(180);
        strokeWeight(1);
        for (let i = 0; i <= gridWidth; i += 6) {
          line(i * cellSize, 0, i * cellSize, gridHeight * cellSize);
          line(0, i * cellSize, gridWidth * cellSize, i * cellSize);
        }

        // Draw studio boundary
        stroke(0);
        strokeWeight(2);
            noFill();
        rect(0, 0, gridWidth * cellSize, gridHeight * cellSize);

        // Add dimension labels
        textSize(10);
        fill(100);
        noStroke();
        
        // Label every 6 feet
        for (let i = 0; i <= gridWidth; i += 6) {
          // X-axis labels (below the grid)
          push();
          translate(i * cellSize, gridHeight * cellSize);
          textAlign(CENTER, TOP);
          text(i + 'ft', 0, 5);
          pop();
          
          // Y-axis labels (left of grid)
          push();
          textAlign(RIGHT, CENTER);
          text(i + 'ft', -5, i * cellSize);
          pop();
        }
      }

      function drawDivisions() {
        // Calculate number of rows and columns based on divisions
        let numDivisions = divisions;
        let numRows, numCols;
        
        // Special handling for 2 divisions
        if (numDivisions === 2) {
          numRows = 1;
          numCols = 2;
        } else if (numDivisions === 9) {
          // For 9 divisions, create a perfect 3x3 grid
          numRows = 3;
          numCols = 3;
        } else {
          numRows = 2;
          numCols = 2;
        }

        // Calculate total available space
        const totalWidth = gridWidth * cellSize;
        const totalHeight = gridHeight * cellSize;
        
        // Calculate path and division sizes
        const pathWidth = 6 * cellSize; // 6ft yellow path
        const effectivePathWidth = 3 * cellSize; // 3ft from each division
        
        // Calculate division sizes accounting for paths
        const availableWidth = totalWidth - (pathWidth * (numCols - 1));
        const availableHeight = totalHeight - (pathWidth * (numRows - 1));
        const divWidth = availableWidth / numCols;
        const divHeight = availableHeight / numRows;
        
        // Draw light grey paths between divisions
        noStroke();
        fill(240, 240, 240, 100); // Very light grey with some transparency
        
        // Draw vertical paths
        for (let i = 1; i < numCols; i++) {
          const pathX = (i * divWidth) + ((i - 1) * pathWidth);
          rect(pathX, 0, pathWidth, totalHeight);
        }
        
        // Draw horizontal paths
        for (let i = 1; i < numRows; i++) {
          const pathY = (i * divHeight) + ((i - 1) * pathWidth);
          rect(0, pathY, totalWidth, pathWidth);
        }
        
        // Draw orange borders around non-path areas
        noFill();
        stroke(0); // Changed from orange to black
        strokeWeight(1); // Made thinner
        drawingContext.setLineDash([5, 5]); // Added dashed pattern
        
        // Draw borders for each division
        for (let row = 0; row < numRows; row++) {
          for (let col = 0; col < numCols; col++) {
            const x = col * (divWidth + pathWidth);
            const y = row * (divHeight + pathWidth);
            rect(x, y, divWidth, divHeight);
          }
        }
        
        // Draw red division lines
        stroke(255, 0, 0);
        strokeWeight(1);
        // Already dashed from above, no need to set again
        
        // Draw vertical division lines - centered in paths
        for (let i = 1; i < numCols; i++) {
          const pathX = (i * divWidth) + ((i - 1) * pathWidth);
          const lineX = pathX + (pathWidth / 2);
          line(lineX, 0, lineX, totalHeight);
        }
        
        // Draw horizontal division lines - centered in paths
        for (let i = 1; i < numRows; i++) {
          const pathY = (i * divHeight) + ((i - 1) * pathWidth);
          const lineY = pathY + (pathWidth / 2);
          line(0, lineY, totalWidth, lineY);
        }
        
        // Reset the line dash pattern
        drawingContext.setLineDash([]);
      }

      function drawDesks() {
        // Draw each desk individually
        let processedCells = new Set();
        let deskNumber = 1;
        
        for (let y = 0; y < gridHeight; y++) {
          for (let x = 0; x < gridWidth; x++) {
            let key = `${x},${y}`;
            if (grid[y][x] === 1 && !processedCells.has(key)) {
              // Check if this is the start of a desk
              let isDesk = true;
              let width = arrangement === 'row' ? deskHeight : deskWidth;  // 6ft wide for rows, 3ft for columns
              let height = arrangement === 'row' ? deskWidth : deskHeight; // 3ft tall for rows, 6ft for columns
              
              // Verify the full desk area
              for (let dy = 0; dy < height && isDesk; dy++) {
                for (let dx = 0; dx < width && isDesk; dx++) {
                  if (y + dy >= gridHeight || x + dx >= gridWidth || grid[y + dy][x + dx] !== 1) {
                    isDesk = false;
                  }
                }
              }
              
              if (isDesk) {
                // Draw the desk
                fill(210, 180, 140); // Light brown (tan) color
                stroke(101, 67, 33); // Dark brown color
                strokeWeight(2);
                rect(x * cellSize, y * cellSize, width * cellSize, height * cellSize);
                
                // Add desk number label
                fill(0);
        noStroke();
                textAlign(CENTER, CENTER);
                textSize(8);
                text(`Desk ${deskNumber}`, 
                     x * cellSize + (width * cellSize) / 2, 
                     y * cellSize + (height * cellSize) / 2);
                
                // Store desk number in deskPositions
                deskPositions[deskNumber - 1] = {
                  x: x,
                  y: y,
                  number: deskNumber,
                  width: width,
                  height: height
                };
                
                deskNumber++;
                
                // Mark all cells in this desk as processed
                for (let dy = 0; dy < height; dy++) {
                  for (let dx = 0; dx < width; dx++) {
                    processedCells.add(`${x + dx},${y + dy}`);
                  }
                }
              }
            }
          }
        }
      }

      function getHeatMapColor(visits) {
        // Normalize visits between 0 and 1, using a logarithmic scale for more gradual changes
        const normalized = Math.log(visits + 1) / Math.log(maxVisits + 1);
        
        // Create a gradient from light grey to black
        const intensity = Math.floor(255 * (1 - normalized));
        const r = intensity;
        const g = intensity;
        const b = intensity;
        
        // Make alpha more sensitive to early visits but still increase with traffic
        const alpha = Math.min(40 + Math.pow(normalized, 0.5) * 215, 255);
        
        return { r, g, b, alpha };
      }

      function updateHeatMap(x, y) {
        const key = `${x},${y}`;
        // Increment visit count
        globalHeatMap[key] = (globalHeatMap[key] || 0) + 1;
        
        // Update maximum visits and trigger color updates more frequently
        if (globalHeatMap[key] > maxVisits) {
          maxVisits = globalHeatMap[key];
          // Force color recalculation for all cells when we hit a new maximum
          for (let pos in globalHeatMap) {
            let color = getHeatMapColor(globalHeatMap[pos]);
            globalHeatMap[pos + '_color'] = color;
          }
        }
      }

      function drawHeatMap() {
        noStroke();
        
        // Draw heat map cells with cached colors
        for (let pos in globalHeatMap) {
          if (pos.includes('_color')) continue; // Skip color cache entries
          
          let [x, y] = pos.split(',').map(Number);
          let visits = globalHeatMap[pos];
          
          // Get color based on visit count
          let color = getHeatMapColor(visits);
          
          // Apply color with proper blending
          fill(color.r, color.g, color.b, color.alpha);
          rect(x * cellSize, y * cellSize, cellSize, cellSize);
          
          // Optional: Add visit count for debugging
          // fill(0);
          // textSize(8);
          // text(visits, x * cellSize + cellSize/2, y * cellSize + cellSize/2);
        }
      }

      function drawHeatMapLegend() {
        if (!legendCanvas) return;
        
        // Clear the legend canvas
        legendCanvas.clear();
        legendCanvas.background(255);
        
        // Get actual canvas dimensions
        const canvasWidth = legendCanvas.width;
        const canvasHeight = legendCanvas.height;
        
        // Calculate legend dimensions with proper margins
        const margin = 10;
        const legendWidth = canvasWidth - (margin * 2);
        const legendHeight = 20;
        const legendX = margin;
        const legendY = margin + 10; // Added extra space at top for "Max Visits" text
        
        // Draw gradient bar
        for (let i = 0; i < legendWidth; i++) {
          const normalized = i / legendWidth;
          const simulatedVisits = Math.floor(Math.pow(maxVisits + 1, normalized)) - 1;
          const color = getHeatMapColor(simulatedVisits);
          legendCanvas.noStroke();
          legendCanvas.fill(color.r, color.g, color.b, color.alpha);
          legendCanvas.rect(legendX + i, legendY, 1, legendHeight);
        }
        
        // Add labels with proper positioning
        legendCanvas.textSize(12);
        legendCanvas.fill(80);
        legendCanvas.noStroke();
        
        // Max visits label at top
        legendCanvas.textAlign(RIGHT, BOTTOM);
        legendCanvas.text(`Max Visits: ${maxVisits}`, legendX + legendWidth, legendY - 2);
        
        // Low/High labels below gradient
        legendCanvas.textAlign(LEFT, TOP);
        legendCanvas.text('Low', legendX, legendY + legendHeight + 5);
        
        legendCanvas.textAlign(RIGHT, TOP);
        legendCanvas.text('High', legendX + legendWidth, legendY + legendHeight + 5);

        // Draw the legend canvas to the HTML canvas element
        let legendElement = document.getElementById('legend-canvas');
        let ctx = legendElement.getContext('2d');
        ctx.clearRect(0, 0, legendElement.width, legendElement.height);
        ctx.drawImage(legendCanvas.elt, 0, 0, legendElement.width, legendElement.height);
      }

      function updateStatistics() {
        // Update interaction counts
        document.getElementById('desks-interacted-count').textContent = desksInteracted;
        document.getElementById('operators-completed-count').textContent = operatorsCompleted;
        
        // Update total counts
        document.getElementById('total-desks-count').textContent = desks;
        document.getElementById('total-operators-count').textContent = parseInt(operatorsSlider.value);
      }

      function getOperatorColor(agent) {
        // Find closest distance to any other operator
        let minDistance = Infinity;
        for (let other of operatorAgents) {
          if (other === agent) continue;
          
          // Calculate distance in feet (each grid cell is 1 foot)
          const dx = Math.abs(agent.x - other.x);
          const dy = Math.abs(agent.y - other.y);
          const distance = Math.sqrt(dx * dx + dy * dy);
          minDistance = Math.min(minDistance, distance);
        }

        // Return color based on distance
        if (minDistance <= 1) {
          return color(255, 0, 0); // Red for <= 1 foot
        } else if (minDistance <= 3) {
          return color(255, 255, 0); // Yellow for 2-3 feet
        } else {
          return color(0, 255, 0); // Green for >= 4 feet
        }
      }

      function updateOperators() {
        // Only update if simulation is running and enough time has passed
        if (isSimulationPaused || performance.now() - lastFrameTime < FRAME_INTERVAL) {
          return;
        }
        lastFrameTime = performance.now();

        // Remove exited operators
        operatorAgents = operatorAgents.filter(agent => !agent.hasExited);
        
        // Sort operators by distance to their assigned desk to prioritize those closer to their target
        operatorAgents.sort((a, b) => {
          if (!a.assignedDesk || !b.assignedDesk) return 0;
          let distA = Math.abs(a.x - a.assignedDesk.x) + Math.abs(a.y - a.assignedDesk.y);
          let distB = Math.abs(b.x - b.assignedDesk.x) + Math.abs(b.y - b.assignedDesk.y);
          return distA - distB;
        });
        
        // Update and draw operators
        for (let agent of operatorAgents) {
          if (!agent.assignedDesk) continue;

          // Store previous position before update
          agent.prevX = agent.x;
          agent.prevY = agent.y;
          
          // Find closest distance to any other operator for color determination
          let minDistance = Infinity;
          for (let other of operatorAgents) {
            if (other === agent || other.hasExited) continue;
            const dx = Math.abs(agent.x - other.x);
            const dy = Math.abs(agent.y - other.y);
            const distance = Math.sqrt(dx * dx + dy * dy);
            minDistance = Math.min(minDistance, distance);
          }

          // Set base color based on distance
          if (minDistance <= 1) {
            fill(255, 0, 0);  // Red for unsafe distance (<1ft)
          } else if (minDistance <= 3) {
            fill(255, 255, 0);  // Yellow for warning distance (2-3ft)
          } else {
            fill(0, 255, 0);  // Green for safe distance (>4ft)
          }

          // Check if at assigned desk
          const dx = Math.abs(agent.x - agent.assignedDesk.x);
          const dy = Math.abs(agent.y - agent.assignedDesk.y);
          const isAtDesk = dx <= 1 && dy <= 1;

          // Set stroke based on state
          if (isAtDesk) {
            stroke(0);
            strokeWeight(3);  // Thick black border when at desk
          } else {
            stroke(0);
            strokeWeight(1);
          }
          
          // Draw operator
          ellipse(agent.x * cellSize + cellSize/2, agent.y * cellSize + cellSize/2, cellSize * 0.8, cellSize * 0.8);
          
          // Add verification tick for completed operators
          if (agent.hasInteracted) {
            push();
            translate(agent.x * cellSize + cellSize/2, agent.y * cellSize + cellSize/2);
            stroke(0);
            strokeWeight(2);
            noFill();
            // Draw check mark
            beginShape();
            vertex(-cellSize * 0.2, 0);
            vertex(0, cellSize * 0.2);
            vertex(cellSize * 0.2, -cellSize * 0.2);
            endShape();
            pop();
          }
          
          // Draw line to assigned desk if not at desk and not completed
          if (!isAtDesk && !agent.hasInteracted) {
            stroke(240, 240, 240); // Very light grey
            strokeWeight(1);
            line(
              agent.x * cellSize + cellSize/2,
              agent.y * cellSize + cellSize/2,
              agent.assignedDesk.x * cellSize + cellSize/2,
              agent.assignedDesk.y * cellSize + cellSize/2
            );
          }
          
          // Update position based on speed with staggered timing
          if (frameCount % Math.max(1, Math.floor(11 - operatorSpeed)) === 0) {
            let nextMove = findNextMove(agent);
            if (nextMove) {
              agent.x = nextMove.x;
              agent.y = nextMove.y;
              agent.visited.add(`${agent.x},${agent.y}`);
              updateHeatMap(agent.x, agent.y);
            }
          }
        }
      }

      function findValidSpawnPoint() {
        // Try to spawn at entry point first
        let spawnX = operatorSource.x;
        let spawnY = operatorSource.y;
        
        // Adjust spawn position based on entry point location
        if (operatorSource.y === -1) spawnY = 0; // Top edge
        else if (operatorSource.y === gridHeight) spawnY = gridHeight - 1; // Bottom edge
        else if (operatorSource.x === -1) spawnX = 0; // Left edge
        else if (operatorSource.x === gridWidth) spawnX = gridWidth - 1; // Right edge
        
        if (isValidMove(spawnX, spawnY)) {
          return { x: spawnX, y: spawnY };
        }
        
        // If entry point is blocked, try nearby points
        const offsets = [
          {dx: -1, dy: 0}, {dx: 1, dy: 0},
          {dx: 0, dy: -1}, {dx: 0, dy: 1},
          {dx: -1, dy: -1}, {dx: -1, dy: 1},
          {dx: 1, dy: -1}, {dx: 1, dy: 1}
        ];
        
        for (let offset of offsets) {
          let x = spawnX + offset.dx;
          let y = spawnY + offset.dy;
          if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight && isValidMove(x, y)) {
            return {x, y};
          }
        }
        
        return null;
      }

      function drawEntryExitPoints() {
        const symbolSize = cellSize * 1.2;
        const textGap = 1;
        const edgeOffset = cellSize; // Distance from grid edge for X-axis arrows
        
        // Draw entry point
        push();
        translate(
          operatorSource.x * cellSize + cellSize/2,
          operatorSource.y === -1 ? -edgeOffset : // Move up for top edge
          operatorSource.y === gridHeight ? gridHeight * cellSize + edgeOffset : // Move down for bottom edge
          operatorSource.y * cellSize + cellSize/2 // Normal Y position for side edges
        );
        
        // Add "ENTRY" text with proper orientation and alignment
        noStroke();
        fill(0);
        textSize(12);
        
        if (operatorSource.x === -1) { // Left edge
          textAlign(RIGHT, TOP);
          text("ENTRY", 0, symbolSize * 0.8);
        } else if (operatorSource.x === gridWidth) { // Right edge
          textAlign(LEFT, TOP);
          text("ENTRY", 0, symbolSize * 0.8);
        } else if (operatorSource.y === -1) { // Top edge
          textAlign(CENTER, BOTTOM);
          text("ENTRY", 0, -symbolSize * 0.3);
        } else { // Bottom edge
          textAlign(CENTER, TOP);
          text("ENTRY", 0, symbolSize * 0.8);
        }
        
        // Rotate arrow based on which edge it's on
        if (operatorSource.y === -1) { // Top edge
          rotate(0); // Point down
        } else if (operatorSource.y === gridHeight) { // Bottom edge
          rotate(PI); // Point up
        } else if (operatorSource.x === -1) { // Left edge
          rotate(PI/2); // Point right
        } else if (operatorSource.x === gridWidth) { // Right edge
          rotate(-PI/2); // Point left
        }
        
        // Draw entry symbol
        stroke(0);
        strokeWeight(2);
        fill(0);
        beginShape();
        vertex(0, symbolSize/2);
        vertex(symbolSize/2, 0);
        vertex(-symbolSize/2, 0);
        endShape(CLOSE);
        pop();
        
        // Draw exit point
        push();
        translate(
          operatorExit.x * cellSize + cellSize/2,
          operatorExit.y === -1 ? -edgeOffset : // Move up for top edge
          operatorExit.y === gridHeight ? gridHeight * cellSize + edgeOffset : // Move down for bottom edge
          operatorExit.y * cellSize + cellSize/2 // Normal Y position for side edges
        );
        
        // Add "EXIT" text with proper orientation and alignment
        noStroke();
        fill(0);
        textSize(12);
        
        if (operatorExit.x === -1) { // Left edge
          textAlign(RIGHT, TOP);
          text("EXIT", 0, symbolSize * 0.8);
        } else if (operatorExit.x === gridWidth) { // Right edge
          textAlign(LEFT, TOP);
          text("EXIT", 0, symbolSize * 0.8);
        } else if (operatorExit.y === -1) { // Top edge
          textAlign(CENTER, BOTTOM);
          text("EXIT", 0, -symbolSize * 0.3);
        } else { // Bottom edge
          textAlign(CENTER, TOP);
          text("EXIT", 0, symbolSize * 0.8);
        }
        
        // Rotate arrow based on which edge it's on
        if (operatorExit.y === -1) { // Top edge
          rotate(0); // Point down
        } else if (operatorExit.y === gridHeight) { // Bottom edge
          rotate(PI); // Point up
        } else if (operatorExit.x === -1) { // Left edge
          rotate(PI/2); // Point right
        } else if (operatorExit.x === gridWidth) { // Right edge
          rotate(-PI/2); // Point left
        }
        
        // Draw exit symbol
        stroke(0);
        strokeWeight(2);
        fill(0);
        beginShape();
        vertex(0, symbolSize/2);
        vertex(symbolSize/2, 0);
        vertex(-symbolSize/2, 0);
        endShape(CLOSE);
        pop();
      }

      function calculateAreas() {
        // Get current division dimensions
        let numDivisions = divisions;
        let numRows, numCols;
        
        if (numDivisions === 2) {
          numRows = 1;
          numCols = 2;
        } else if (numDivisions === 9) {
          numRows = 3;
          numCols = 3;
        } else {
          numRows = 2;
          numCols = 2;
        }

        // Calculate areas
        const totalStudioArea = gridWidth * gridHeight;
        const pathWidth = 6; // 6ft yellow path
        
        // Calculate main corridor area (yellow paths)
        const horizontalPathArea = (numRows - 1) * gridWidth * pathWidth;
        const verticalPathArea = (numCols - 1) * gridHeight * pathWidth;
        const mainCorridorArea = horizontalPathArea + verticalPathArea - ((numRows - 1) * (numCols - 1) * pathWidth * pathWidth);

        // Calculate total desk area
        const deskArea = deskPositions.length * (arrangement === 'row' ? 12 : 12); // Each desk is 6x2 or 2x6 = 12 sq ft

        // Calculate division areas
        const totalUsableWidth = gridWidth - (pathWidth * (numCols - 1));
        const totalUsableHeight = gridHeight - (pathWidth * (numRows - 1));
        const divWidth = Math.floor(totalUsableWidth / numCols);
        const divHeight = Math.floor(totalUsableHeight / numRows);
        const divisionArea = divWidth * divHeight;

        // Calculate desk area per division
        const desksPerDivision = Math.floor(deskPositions.length / numDivisions);
        const deskAreaPerDivision = desksPerDivision * 12;

        // Update the display
        document.getElementById('total-studio-area').textContent = totalStudioArea;
        document.getElementById('main-corridor-area').textContent = mainCorridorArea;
        document.getElementById('total-desk-area').textContent = deskArea;
        document.getElementById('total-non-desk-area').textContent = totalStudioArea - deskArea - mainCorridorArea;
        
        document.getElementById('division-total-area').textContent = divisionArea;
        document.getElementById('division-desk-area').textContent = deskAreaPerDivision;
        document.getElementById('division-non-desk-area').textContent = divisionArea - deskAreaPerDivision;
      }
    </script>
  </body>
</html>